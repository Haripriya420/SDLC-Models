<!DOCTYPE html>
<html>
    <head>
        <title>V Model</title> 
        <link rel="stylesheet" href=".\style.css"/>     
    </head>
    <body>
        <div class="container" style="gap: 8%;">
           <div></div>
           <div></div>
           <div></div>
            <div><center><p>V Model</p></center></div>
            <div></div>
            <div></div>
            
           <div>
            <img class="img1"  style="height: 250px; width: 500px;" src="https://media.istockphoto.com/id/1474349837/photo/software-development-that-is-agile-business-developer-employing-computer-with-virtual-screen.jpg?s=612x612&w=0&k=20&c=Eg2StZ5vavWsJ4vRHf5r4MDajEbrHM00ZnnYbSt_vRA="  alt="SDLC"/>
            </div>
        </div>
        
        <div class="parent">
        <div class="side">
            <ul class="list">
                
                <li class="child"><a href=".\main.html">SDLC-Home</a></li>
                <li class="child"><a href=".\waterfall.html">WaterFall Model</a></li>
                <li class="child"><a href=".\vmodel.html">V Model</a></li>
                <li class="child"><a href=".\evol.html">Evolution Model</a></li>
                <li class="child"><a href=".\inc.html">Incremental  Model</a></li>
                <li class="child"><a href=".\iterative.html">Iterative Model</a></li>
                <li class="child"><a href=".\spiral.html">Spiral Model</a></li>
                <li class="child"><a href=".\rad.html">RAD Model</a></li>
                <li class="child"><a href=".\prototype.html">Prototype Model</a></li>
                <li class="child"><a href=".\agile.html">Agile Model</a></li>
                
              </ul>

             </div> 
             <div class="center1">
            <center><h1>V Model</h1></center>
            <blockquote>
            <p id="para">The V-model is an SDLC model where execution of processes happens in a sequential manner in a V-shape. It is also known as Verification and Validation model.</p>

            <p id="para">The V-Model is an extension of the waterfall model and is based on the association of a testing phase for each corresponding development stage. This means that for every single phase in the development cycle, there is a directly associated testing phase. This is a highly-disciplined model and the next phase starts only after completion of the previous phase.
            </p>
            </blockquote>
            <h3 id="topic1">V-Model - Design</h3>
            <blockquote>
            <p id="para">Under the V-Model, the corresponding testing phase of the development phase is planned in parallel. So, there are Verification phases on one side of the ‘V’ and Validation phases on the other side. The Coding Phase joins the two sides of 
                the V-Model.</p>
             </blockquote>
             <blockquote>
                <center>
             <img  src="https://www.tutorialspoint.com/sdlc/images/sdlc_v_model.jpg" alt="waterfall"/>
             </center>
             </blockquote>
             <h3 id="topic1"> V-Model - Verification Phases :</h3>
             <blockquote>
                <div class="extra" >
                    <ul>
                        <li><b>Business Requirement Analysis − </b>This is the first phase in the development cycle where the product requirements are understood from the customer’s perspective. This phase involves detailed communication with the customer to understand his expectations and exact requirement. This is a very important activity and needs to be managed well, as most of the customers are not sure about what exactly they need. The acceptance test design planning is done at this stage 
                            as business requirements can be used as an input for acceptance testing.</li><br>
                         <li><b>System Design −</b>Once you have the clear and detailed product requirements, it is time to design the complete system. The system design will have the understanding and detailing the complete hardware and communication setup for the product under development. The system test plan is developed based on 
                            the system design. Doing this at an earlier stage leaves more time for the actual test execution later.</li><br>
                         <li><b>Architectural Design −</b>Architectural specifications are understood and designed in this phase. Usually more than one technical approach is proposed and based on the technical and financial feasibility the final decision is taken. The system design is broken down further into modules taking up different functionality. 
                            This is also referred to as High Level Design (HLD).</li><br>
                         <li><b>Module Design −</b>In the module design phase, the system breaks down into small modules. The detailed design of the modules is specified, which is known as Low-Level Design</li>
                         <br>
                         <li><b>Coding Phase −</b>After designing, the coding phase is started. Based on the requirements, a suitable programming language is decided. There are some guidelines and standards for coding. Before checking in the repository, the final build is optimized for better performance, and the code goes through
                             many code reviews to check the performance.</li>
                         <br>
                        </ul>
                </div> 
                <h3 id="topic1"> V-Model - Validation  Phases :</h3>
             <blockquote>
                <div class="extra" >
                    <ul>
                        <li><b>Unit Testing − </b>In the V-Model, Unit Test Plans (UTPs) are developed during the module design phase. These UTPs are executed to eliminate errors at code level or unit level. A unit is the smallest entity which can independently exist, e.g., a program module. Unit testing verifies that the smallest entity can function correctly when isolated from the rest of the codes/ units.</li><br>
                         <li><b>Integration Testing −</b> Integration Test Plans are developed during the Architectural Design Phase. These tests verify that groups created and tested independently can coexist and communicate among themselves.</li><br>
                         <li><b>System Testing −</b>System Tests Plans are developed during System Design Phase. Unlike Unit and Integration Test Plans, System Tests Plans are composed by the client?s business team. System Test ensures that expectations from an application developer are met.</li><br>
                         <li><b>Acceptance Testing −</b>Acceptance testing is related to the business requirement analysis part. It includes testing the software product in user atmosphere. Acceptance tests reveal the compatibility problems with the different systems, which is available within the user atmosphere. It conjointly discovers the non-functional problems like load and performance defects within the real user atmosphere.</li><br>
                         
                        </ul>
                </div> 
            </blockquote>
            <h3 id="topic1">V Model - Application </h3>
            <blockquote>
            <div class="extra" >
                <ul>
                 <li>Requirements are very well documented, clear and fixed.</li><br>                
                 <li>Product definition is stable.</li><br> 
                 <li>  Technology is understood and is not dynamic.</li><br> 
                 <li>  There are no ambiguous requirements.</li><br> 
                 <li>  Ample resources with required expertise are available to support the product.</li><br>                
                 <li>The project is short.</li><br>                
                </ul>
            </div> 
            </blockquote>
            
            <h3 id="topic1">V Model - Advantages </h3>
            <blockquote>
            <div class="extra" >
                <ul>
                 <li>Simple and easy to understand and use</li><br> 
                 <li> Works well for smaller projects where requirements are very well understood.</li><br> 
                <li> Clearly defined stages.</li><br> 
                <li> Well understood milestones.</li><br> 
                <li> Easy to arrange tasks.</li><br> 
                <li> Process and results are well documented.</li><br>                
                </ul>
            </div>
            </blockquote>
            
            <h3 id="topic1"> V Model - Disadvantages</h3>
            <blockquote>
            <div class="extra" >
                <ul>
                <li> No working software is produced until late during the life cycle.</li><br>
                <li> High amounts of risk and uncertainty.</li><br>
                <li>Not a good model for complex and object-oriented projects.</li><br>
                <li>Poor model for long and ongoing projects.</li><br>
                <li>Not suitable for the projects where requirements are at a moderate to high
                     risk of changing. So, risk and uncertainty is high with this process model.</li><br>
                <li>Cannot accommodate changing requirements.</li><br>
                </ul>
            </div>
                </blockquote>
            
                <br><br><br><br><br>

                <hr>
                
                <br><br>
                <a href="./waterfall.html" >
                    <button class="button2" >&nbsp;Previous&nbsp;</button>
                    </a>
    
                <a href="./evol.html" >
                <button class="button1" >&nbsp;Next&nbsp;</button>
                </a>
    
                <br><br><br><br><br>
            
        </div>
        
        </div>
    


    </body>
</html>